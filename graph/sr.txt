package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.25

import (
	"context"
	"fmt"
  "log"

	"github.com/johnietre/projects-tracker/auth"
	"github.com/johnietre/projects-tracker/database"
	"github.com/johnietre/projects-tracker/graph/model"
	"github.com/johnietre/projects-tracker/jwt"
)

var serverErr = fmt.Errorf("Internal server error")

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (string, error) {
  user, err := r.db.CreateUser(input)
  if err != nil {
    if !errors.Is(err, database.ErrUserExist) {
      log.Printf("error creating user for %s: %v", input.Email, err)
      err = serverErr
    }
  }
  token, err := jwt.GenerateToken(user.Email)
  if err != nil {
    log.Printf("error generating token for %s: %v", user.Email)
    return "1", serverErr
  }
  return token, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginUserInput) (string, error) {
  user, err := r.db.LoginUser(input)
  if err != nil {
    if !errors.Is(err, database.ErrUserNotExist) {
      log.Printf("error logging user for %s: %v", input.Email, err)
      err = serverErr
    }
  }
  token, err := jwt.GenerateToken(user.Email)
  if err != nil {
    log.Printf("error generating token for %s: %v", user.Email)
    return "1", serverErr
  }
  return token, nil
}

// CreatePart is the resolver for the createPart field.
func (r *mutationResolver) CreatePart(ctx context.Context, input model.CreatePartInput) (*model.Part, error) {
  user, ok := auth.UserFromContext(ctx)
  if !ok {
    return nil, fmt.Errorf("Access deined")
  }
  part, err := r.db.CreatePart(user.Email, input)
  if err != nil {
    log.Printf("error creating part for %s (input: %s): %v", user.Email, input, err)
    return nil, serverErr
  }
  return part, nil
}

// UpdatePart is the resolver for the updatePart field.
func (r *mutationResolver) UpdatePart(ctx context.Context, input model.UpdatePartInput) (*model.Part, error) {
  user, ok := auth.UserFromContext(ctx)
  if !ok {
    return nil, fmt.Errorf("Access deined")
  }
  part, err := r.db.UpdatePart(user.Email, input)
  if err != nil {
    if !errors.Is(err, database.ErrPartNotExist) {
      log.Printf("error updating part for %s (input: %v): %v", user.Email, input, err)
      err = serverErr
    }
    return nil, err
  }
  return part, nil
}

// Parts is the resolver for the parts field.
func (r *queryResolver) Parts(ctx context.Context) ([]*model.Part, error) {
  user, ok := auth.UserFromContext(ctx)
  if !ok {
    return nil, fmt.Errorf("Access deined")
  }
  parts, err := r.db.GetParts(user.Email)
  if err != nil {
    log.Printf("error getting parts for %s: %v", user.Email, err)
    err = serverErr
  }
  return parts, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
