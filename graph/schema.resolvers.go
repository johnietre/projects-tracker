package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.25

import (
	"context"
	"errors"
	"log"

	"github.com/johnietre/projects-tracker/auth"
	"github.com/johnietre/projects-tracker/database"
	"github.com/johnietre/projects-tracker/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (string, error) {
	user, err := r.db.CreateUser(input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error creating user for %s: %v", input.Email, err)
			err = serverErr
		}
		return "", err
	}
	token, err := auth.GenerateToken(user.Email)
	if err != nil {
		log.Printf("error generating token for %s: %v", user.Email, err)
		return "", serverErr
	}
	auth.AddCookieToContext(ctx, token)
	return token, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginUserInput) (string, error) {
	user, err := r.db.LoginUser(input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error logging user for %s: %v", input.Email, err)
			err = serverErr
		}
		return "", nil
	}
	token, err := auth.GenerateToken(user.Email)
	if err != nil {
		log.Printf("error generating token for %s: %v", user.Email, err)
		return "", serverErr
	}
	auth.AddCookieToContext(ctx, token)
	return token, nil
}

// LogoutUser is the resolver for the logoutUser field.
func (r *mutationResolver) LogoutUser(ctx context.Context) (bool, error) {
	if !auth.RemoveCookieFromContext(ctx) {
		log.Printf("error removing cookie from context")
		return false, serverErr
	}
	return true, nil
}

// CreatePart is the resolver for the createPart field.
func (r *mutationResolver) CreatePart(ctx context.Context, input model.CreatePartInput) (*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, ErrAccess
	}
	part, err := r.db.CreatePart(user.Email, input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error creating part for %s (input: %v): %v", user.Email, input, err)
			err = serverErr
		}
		// TODO: Do I NEED to return something on error?
		part = &model.Part{}
	}
	return part, err
}

// UpdatePart is the resolver for the updatePart field.
func (r *mutationResolver) UpdatePart(ctx context.Context, id string, changes map[string]interface{}) (*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, ErrAccess
	}
	part, err := r.db.UpdatePart(user.Email, id, changes)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf(
				"error updating part for %s (id: %s, input: %v): %v",
				user.Email, id, changes, err,
			)
			err = serverErr
		}
		// TODO: Do I NEED to return something on error?
		return &model.Part{}, err
	}
	return part, nil
}

// DeletePart is the resolver for the deletePart field.
func (r *mutationResolver) DeletePart(ctx context.Context, id string) (string, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return "", ErrAccess
	}
	err := r.db.DeletePart(user.Email, id)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf(
				"error deleting part (id: %s) for %s: %v",
				id, user.Email, err,
			)
			err = serverErr
		}
		return "", err
	}
	return id, nil
}

// Parts is the resolver for the parts field.
func (r *queryResolver) Parts(ctx context.Context) ([]*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, ErrAccess
	}
	parts, err := r.db.GetParts(user.Email)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error getting parts for %s: %v", user.Email, err)
			err = serverErr
		}
		// TODO: Do I NEED to return something on error?
	}
	return parts, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var ErrAccess = errors.New("Access denied")
