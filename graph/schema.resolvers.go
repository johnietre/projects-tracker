package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.25

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/johnietre/projects-tracker/auth"
	"github.com/johnietre/projects-tracker/database"
	"github.com/johnietre/projects-tracker/graph/model"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (string, error) {
	user, err := r.db.CreateUser(input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error creating user for %s: %v", input.Email, err)
			err = serverErr
		}
	}
	token, err := auth.GenerateToken(user.Email)
	if err != nil {
		log.Printf("error generating token for %s: %v", user.Email)
		return "1", serverErr
	}
	return token, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input model.LoginUserInput) (string, error) {
	user, err := r.db.LoginUser(input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error logging user for %s: %v", input.Email, err)
			err = serverErr
		}
	}
	token, err := auth.GenerateToken(user.Email)
	if err != nil {
		log.Printf("error generating token for %s: %v", user.Email)
		return "1", serverErr
	}
	return token, nil
}

// CreatePart is the resolver for the createPart field.
func (r *mutationResolver) CreatePart(ctx context.Context, input model.CreatePartInput) (*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("Access deined")
	}
	part, err := r.db.CreatePart(user.Email, input)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error creating part for %s (input: %s): %v", user.Email, input, err)
			return nil, serverErr
		}
	}
	return part, nil
}

// UpdatePart is the resolver for the updatePart field.
func (r *mutationResolver) UpdatePart(ctx context.Context, id string, changes map[string]interface{}) (*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("Access deined")
	}
	part, err := r.db.UpdatePart(user.Email, id, changes)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf(
				"error updating part for %s (id: %s, input: %v): %v",
				user.Email, id, changes, err,
			)
			err = serverErr
		}
		return nil, err
	}
	return part, nil
	return nil, nil
}

// DeletePart is the resolver for the deletePart field.
func (r *mutationResolver) DeletePart(ctx context.Context, id string) (bool, error) {
  user, ok := auth.UserFromContext(ctx)
  if !ok {
    return nil, fmt.Errorf("Access denied")
  }
  err := r.db.DeletePart(user.Email, id)
  if err != nil {
    if !errors.As(err, &database.UserError{}) {
      log.Printf(
        "error deleting part (id: %s) for %s: %v",
        id, user.Email, err,
      )
      err = serverErr
    }
  }
  return err == nil, err
}

// Parts is the resolver for the parts field.
func (r *queryResolver) Parts(ctx context.Context) ([]*model.Part, error) {
	user, ok := auth.UserFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("Access deined")
	}
	parts, err := r.db.GetParts(user.Email)
	if err != nil {
		if !errors.As(err, &database.UserError{}) {
			log.Printf("error getting parts for %s: %v", user.Email, err)
			err = serverErr
		}
	}
	return parts, err
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
